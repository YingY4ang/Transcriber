<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clinical Recorder</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      padding: 40px;
      width: 100%;
      max-width: 600px;
      animation: slideUp 0.6s ease-out;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    h1 {
      text-align: center;
      color: #2d3748;
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      text-align: center;
      color: #718096;
      margin-bottom: 30px;
      font-size: 1.1rem;
    }

    .tips {
      background: linear-gradient(135deg, #e6fffa, #f0fff4);
      border: 1px solid #38b2ac;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 30px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .tips-icon {
      font-size: 1.5rem;
    }

    .tips-text {
      color: #2d5a5a;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: #4a5568;
      font-weight: 600;
      font-size: 0.9rem;
    }

    input, select {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
      background: white;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }

    .file-input-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    .file-input {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .file-input-display {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 14px 16px;
      border: 2px dashed #cbd5e0;
      border-radius: 12px;
      background: #f7fafc;
      color: #718096;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .file-input-display:hover {
      border-color: #667eea;
      background: #edf2f7;
    }

    .buttons {
      display: flex;
      gap: 15px;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    button {
      flex: 1;
      min-width: 140px;
      padding: 16px 24px;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    button:before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    button:hover:before {
      left: 100%;
    }

    .btn-primary {
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: white;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }

    .btn-primary.recording {
      background: linear-gradient(135deg, #f44336, #d32f2f);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3); }
      50% { box-shadow: 0 4px 25px rgba(244, 67, 54, 0.6); }
      100% { box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3); }
    }

    .btn-secondary {
      background: linear-gradient(135deg, #2196F3, #1976D2);
      color: white;
      box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
    }

    .btn-secondary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
    }

    .btn-fhir {
      background: linear-gradient(135deg, #9C27B0, #7B1FA2);
      color: white;
      box-shadow: 0 4px 15px rgba(156, 39, 176, 0.3);
      display: none;
    }

    .btn-fhir:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4);
    }

    .progress-container {
      display: none;
      margin: 20px 0;
    }

    .progress-bar-wrapper {
      background: #e2e8f0;
      border-radius: 10px;
      overflow: hidden;
      height: 8px;
      margin-bottom: 10px;
    }

    .progress-bar {
      background: linear-gradient(90deg, #4CAF50, #45a049);
      height: 100%;
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 10px;
    }

    .progress-text {
      text-align: center;
      color: #4a5568;
      font-size: 0.9rem;
      font-weight: 600;
    }

    .status {
      text-align: center;
      padding: 16px;
      border-radius: 12px;
      margin: 20px 0;
      font-weight: 600;
      background: #f7fafc;
      color: #4a5568;
      border: 1px solid #e2e8f0;
    }

    .timer {
      text-align: center;
      font-weight: 700;
      color: #667eea;
      margin: 15px 0;
      font-size: 1.1rem;
      display: none;
    }

    .result {
      display: none;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      margin-top: 20px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.5;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .result::-webkit-scrollbar {
      width: 8px;
    }

    .result::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .result::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 4px;
    }

    .result::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    /* Tab Navigation */
    .tab-nav {
      display: flex;
      margin-bottom: 30px;
      background: #f7fafc;
      border-radius: 12px;
      padding: 4px;
    }

    .tab-btn {
      flex: 1;
      padding: 12px 20px;
      border: none;
      background: transparent;
      border-radius: 8px;
      font-weight: 600;
      color: #718096;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .tab-btn.active {
      background: white;
      color: #667eea;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .tab-btn:hover:not(.active) {
      color: #4a5568;
    }

    /* Tab Content */
    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Patient Search Styles */
    .search-wrapper {
      display: flex;
      gap: 10px;
    }

    .search-wrapper input {
      flex: 1;
    }

    .btn-search {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 14px 20px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: auto;
    }

    .btn-search:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .patient-results {
      margin: 20px 0;
      min-height: 100px;
    }

    .no-results {
      text-align: center;
      color: #718096;
      padding: 40px 20px;
    }

    .no-results-icon {
      font-size: 3rem;
      display: block;
      margin-bottom: 10px;
    }

    .patient-details {
      background: #f8fafc;
      border-radius: 12px;
      padding: 20px;
      margin-top: 20px;
    }

    .patient-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid #e2e8f0;
    }

    .patient-header h3 {
      color: #2d3748;
      font-size: 1.5rem;
      margin: 0;
    }

    .patient-nhi {
      background: #667eea;
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 600;
    }

    .patient-info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
    }

    .info-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .info-card h4 {
      color: #2d3748;
      margin-bottom: 15px;
      font-size: 1.1rem;
      border-bottom: 2px solid #e2e8f0;
      padding-bottom: 8px;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      padding: 8px 0;
    }

    .info-item .label {
      font-weight: 600;
      color: #4a5568;
    }

    .info-item span:last-child {
      color: #2d3748;
    }

    .encounters-list, .medications-list, .conditions-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .no-data {
      color: #718096;
      font-style: italic;
      text-align: center;
      padding: 20px;
    }

    .encounter-item, .medication-item, .condition-item {
      background: #f7fafc;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      border-left: 4px solid #667eea;
    }

    .encounter-date, .medication-date {
      font-size: 0.8rem;
      color: #718096;
      margin-bottom: 4px;
    }

    .encounter-type, .medication-name, .condition-name {
      font-weight: 600;
      color: #2d3748;
    }

    /* Editable Elements */
    .editable {
      background: #f7fafc;
      border: 1px solid transparent;
      border-radius: 4px;
      padding: 4px 8px;
      transition: all 0.2s ease;
      cursor: text;
    }

    .editable:hover {
      background: #edf2f7;
      border-color: #cbd5e0;
    }

    .editable:focus {
      background: white;
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }

    .editable-select {
      background: #f7fafc;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.9rem;
      cursor: pointer;
      width: 140px;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 8px center;
      background-repeat: no-repeat;
      background-size: 16px;
      padding-right: 32px;
    }

    .editable-select:focus {
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }

    .editable-input {
      background: #f7fafc;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.9rem;
      width: 140px;
    }

    .editable-input:focus {
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }

    .edit-actions {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #e2e8f0;
    }

    .btn-save, .btn-add {
      background: linear-gradient(135deg, #48bb78, #38a169);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-save:hover, .btn-add:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3);
    }

    .btn-add {
      width: 100%;
      margin-top: 10px;
      background: linear-gradient(135deg, #667eea, #764ba2);
    }

    .btn-add:hover {
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    /* Inline Add Forms */
    .add-form {
      background: #f7fafc;
      border-radius: 8px;
      padding: 12px;
      margin: 10px 0;
      border: 1px solid #e2e8f0;
    }

    .form-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #cbd5e0;
      border-radius: 6px;
      font-size: 0.9rem;
      margin-bottom: 8px;
    }

    .form-input:focus {
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }

    .form-buttons {
      display: flex;
      gap: 8px;
    }

    .btn-save-small, .btn-cancel-small {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-save-small {
      background: #48bb78;
      color: white;
    }

    .btn-save-small:hover {
      background: #38a169;
    }

    .btn-cancel-small {
      background: #e2e8f0;
      color: #4a5568;
    }

    .btn-cancel-small:hover {
      background: #cbd5e0;
    }

    /* AI Summary Styles */
    .ai-summary {
      background: #f8fafc;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
      min-height: 100px;
      border-left: 4px solid #667eea;
      font-size: 0.9rem;
      line-height: 1.5;
    }

    .btn-ai {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 100%;
    }

    .btn-ai:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .btn-ai:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
      transform: none;
    }

    @media (max-width: 640px) {
      .container {
        padding: 20px;
        margin: 10px;
      }

      h1 {
        font-size: 2rem;
      }

      .buttons {
        flex-direction: column;
      }

      button {
        min-width: auto;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Clinical Recorder</h1>
    <p class="subtitle">AI-powered clinical transcription for healthcare professionals</p>
    
    <!-- Tab Navigation -->
    <div class="tab-nav">
      <button class="tab-btn active" data-tab="recording">üé§ Recording</button>
      <button class="tab-btn" data-tab="patients">üë• Patient Search</button>
    </div>

    <!-- Recording Tab -->
    <div id="recording-tab" class="tab-content active">
      <div class="tips">
        <span class="tips-icon">üí°</span>
        <div class="tips-text">
          <strong>Audio Tips:</strong> Speak clearly, minimize background noise, position microphone 6-12 inches from mouth for optimal results
        </div>
      </div>

      <div class="form-group">
        <label for="patientId">Patient NHI or ID</label>
        <input id="patientId" placeholder="Enter patient identifier" type="text">
      </div>

      <div class="form-group">
        <label for="micSelect">Microphone</label>
        <select id="micSelect">
          <option value="">Select Microphone...</option>
        </select>
      </div>
        <select id="micSelect">
          <option value="">Select Microphone...</option>
        </select>
      </div>

      <div class="form-group">
        <label>Upload Audio File</label>
        <div class="file-input-wrapper">
          <input type="file" id="audioFile" accept="audio/*,.webm,.mp3,.wav,.m4a,.ogg" class="file-input">
          <div class="file-input-display">
            <span>üìÅ</span>
            <span>Choose audio file or drag & drop</span>
          </div>
        </div>
      </div>

      <div class="buttons">
        <button id="record" class="btn-primary">üé§ Start Recording</button>
        <button id="uploadFile" class="btn-secondary">üì§ Upload Audio File</button>
      </div>

      <button id="sendToFhir" class="btn-fhir">üè• Send to FHIR Server</button>

      <div id="progressContainer" class="progress-container">
        <div class="progress-bar-wrapper">
          <div id="progressBar" class="progress-bar"></div>
        </div>
        <div id="progressText" class="progress-text">0%</div>
      </div>

      <div id="status" class="status">Ready to record or upload audio</div>
      <div id="timer" class="timer">Processing time: <span id="timerValue">0</span>s</div>
      <div id="result" class="result"></div>
    </div>

    <!-- Patient Search Tab -->
    <div id="patients-tab" class="tab-content">
      <div class="form-group">
        <label for="searchNhi">Search by NHI or Name</label>
        <div class="search-wrapper">
          <input id="searchNhi" placeholder="Enter NHI number or patient name" type="text">
          <button id="searchBtn" class="btn-search">üîç Search</button>
        </div>
      </div>

      <div id="patientResults" class="patient-results">
        <div class="no-results">
          <span class="no-results-icon">üë§</span>
          <p>Enter a patient NHI or name to search</p>
        </div>
      </div>

      <div id="patientDetails" class="patient-details" style="display: none;">
        <div class="patient-header">
          <h3 id="patientName">Patient Name</h3>
          <span id="patientNhi" class="patient-nhi">NHI: ABC1234</span>
        </div>
        
        <div class="patient-info-grid">
          <div class="info-card">
            <h4>AI Clinical Summary</h4>
            <div id="aiSummary" class="ai-summary">
              <p class="no-data">Generate AI summary after patient data loads</p>
            </div>
            <button id="generateSummary" class="btn-ai" style="display: none;">ü§ñ Generate AI Summary</button>
          </div>

          <div class="info-card">
            <h4>Demographics</h4>
            <div class="info-item">
              <span class="label">Date of Birth:</span>
              <input type="date" id="patientDob" class="editable-input" data-field="birthDate">
            </div>
            <div class="info-item">
              <span class="label">Gender:</span>
              <select id="patientGender" class="editable-select" data-field="gender">
                <option value="">Select...</option>
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="other">Other</option>
                <option value="unknown">Unknown</option>
              </select>
            </div>
            <div class="info-item">
              <span class="label">Address:</span>
              <span id="patientAddress" class="editable" data-field="address" contenteditable="true">-</span>
            </div>
            <div class="edit-actions">
              <button id="savePatient" class="btn-save">üíæ Save Changes</button>
            </div>
          </div>

          <div class="info-card">
            <h4>Recent Encounters</h4>
            <div id="recentEncounters" class="encounters-list">
              <p class="no-data">No recent encounters</p>
            </div>
            <div id="addEncounterForm" class="add-form" style="display: none;">
              <input type="text" id="encounterTypeInput" placeholder="Enter encounter type (e.g., Consultation)" class="form-input">
              <div class="form-buttons">
                <button id="saveEncounter" class="btn-save-small">‚úì Save</button>
                <button id="cancelEncounter" class="btn-cancel-small">‚úó Cancel</button>
              </div>
            </div>
            <button id="addEncounter" class="btn-add">‚ûï Add Encounter</button>
          </div>

          <div class="info-card">
            <h4>Current Medications</h4>
            <div id="currentMedications" class="medications-list">
              <p class="no-data">No current medications</p>
            </div>
            <div id="addMedicationForm" class="add-form" style="display: none;">
              <input type="text" id="medicationNameInput" placeholder="Enter medication name" class="form-input">
              <input type="date" id="medicationDateInput" placeholder="Start date" class="form-input">
              <div class="form-buttons">
                <button id="saveMedication" class="btn-save-small">‚úì Save</button>
                <button id="cancelMedication" class="btn-cancel-small">‚úó Cancel</button>
              </div>
            </div>
            <button id="addMedication" class="btn-add">‚ûï Add Medication</button>
          </div>

          <div class="info-card">
            <h4>Conditions</h4>
            <div id="patientConditions" class="conditions-list">
              <p class="no-data">No active conditions</p>
            </div>
            <div id="addConditionForm" class="add-form" style="display: none;">
              <input type="text" id="conditionNameInput" placeholder="Enter condition name" class="form-input">
              <div class="form-buttons">
                <button id="saveCondition" class="btn-save-small">‚úì Save</button>
                <button id="cancelCondition" class="btn-cancel-small">‚úó Cancel</button>
              </div>
            </div>
            <button id="addCondition" class="btn-add">‚ûï Add Condition</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Auto-populate from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const patientId = urlParams.get('patientId');
    const patientName = urlParams.get('name');
    
    if (patientId) {
      document.getElementById('patientId').value = patientId;
      document.getElementById('patientId').readOnly = true;
    }
    if (patientName) {
      document.querySelector('h1').textContent = `Clinical Recorder - ${patientName}`;
    }

    const API_URL = 'http://52.63.25.129:5000'; // Your EC2 public IP
    // Get WebSocket URL from backend
    let WEBSOCKET_URL = 'wss://cmxbu5k037.execute-api.ap-southeast-2.amazonaws.com/prod'; // fallback
    
    // Fetch config asynchronously
    fetch(`${API_URL}/config`)
      .then(res => res.json())
      .then(config => {
        WEBSOCKET_URL = config.websocketUrl;
      })
      .catch(err => console.log('Config fetch failed, using fallback WebSocket URL')); // Your backend URL
    
    let recorder, chunks = [];
    let isRecording = false;
    const btn = document.getElementById('record');
    const status = document.getElementById('status');
    const result = document.getElementById('result');
    const micSelect = document.getElementById('micSelect');
    const timer = document.getElementById('timer');
    const timerValue = document.getElementById('timerValue');
    const sendToFhirBtn = document.getElementById('sendToFhir');
    
    let startTime = null;
    let timerInterval = null;
    let currentFhirBundle = null;

    // Tab switching functionality
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tabName = btn.dataset.tab;
        
        // Update active tab button
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Update active tab content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(`${tabName}-tab`).classList.add('active');
      });
    });

    // Patient search functionality
    document.getElementById('searchBtn').addEventListener('click', searchPatient);
    document.getElementById('searchNhi').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') searchPatient();
    });

    async function searchPatient() {
      const searchTerm = document.getElementById('searchNhi').value.trim();
      if (!searchTerm) return;

      const resultsDiv = document.getElementById('patientResults');
      const detailsDiv = document.getElementById('patientDetails');
      
      resultsDiv.innerHTML = '<div class="no-results"><span class="no-results-icon">‚è≥</span><p>Searching...</p></div>';
      detailsDiv.style.display = 'none';

      try {
        // Search in local FHIR server
        const response = await fetch(`http://localhost:8080/fhir/Patient?identifier=https://standards.digital.health.nz/ns/nhi-id|${searchTerm}`);
        const bundle = await response.json();

        if (bundle.total > 0) {
          const patient = bundle.entry[0].resource;
          displayPatientDetails(patient);
          
          // Fetch additional data
          await fetchPatientEncounters(patient.id);
          await fetchPatientMedications(patient.id);
          await fetchPatientConditions(patient.id);
        } else {
          resultsDiv.innerHTML = '<div class="no-results"><span class="no-results-icon">‚ùå</span><p>No patient found with that NHI</p></div>';
        }
      } catch (error) {
        console.error('Search error:', error);
        resultsDiv.innerHTML = '<div class="no-results"><span class="no-results-icon">‚ö†Ô∏è</span><p>Search failed. Please try again.</p></div>';
      }
    }

    function displayPatientDetails(patient) {
      const resultsDiv = document.getElementById('patientResults');
      const detailsDiv = document.getElementById('patientDetails');
      
      resultsDiv.innerHTML = '<div class="no-results"><span class="no-results-icon">‚úÖ</span><p>Patient found</p></div>';
      
      // Update patient header
      document.getElementById('patientName').textContent = 
        patient.name ? `${patient.name[0].given?.[0] || ''} ${patient.name[0].family || ''}`.trim() : 'Unknown';
      document.getElementById('patientNhi').textContent = 
        `NHI: ${patient.identifier?.[0]?.value || 'Unknown'}`;
      
      // Update demographics
      document.getElementById('patientDob').value = patient.birthDate || '';
      document.getElementById('patientGender').value = patient.gender || '';
      document.getElementById('patientAddress').textContent = 
        patient.address?.[0]?.text || patient.address?.[0]?.line?.[0] || '-';
      
      detailsDiv.style.display = 'block';
      
      // Store current patient for editing
      window.currentPatient = patient;
      
      // Show AI summary button
      document.getElementById('generateSummary').style.display = 'block';
    }

    // Generate AI Summary
    document.getElementById('generateSummary').addEventListener('click', async () => {
      if (!window.currentPatient) return;
      
      const btn = document.getElementById('generateSummary');
      const summaryDiv = document.getElementById('aiSummary');
      
      try {
        btn.disabled = true;
        btn.textContent = 'ü§ñ Generating...';
        summaryDiv.innerHTML = '<p style="color: #667eea;">ü§ñ AI is analyzing patient history...</p>';
        
        // Gather all patient data
        const patientData = await gatherPatientData(window.currentPatient.id);
        
        // Send to your backend for AI processing
        const response = await fetch(`${API_URL}/ai-summary`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            patientId: window.currentPatient.id,
            patientData: patientData
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          summaryDiv.innerHTML = `<div style="white-space: pre-wrap;">${result.summary}</div>`;
        } else {
          throw new Error('Failed to generate summary');
        }
      } catch (error) {
        summaryDiv.innerHTML = '<p style="color: #e53e3e;">‚ùå Failed to generate AI summary. Please try again.</p>';
        console.error('AI Summary error:', error);
      } finally {
        btn.disabled = false;
        btn.textContent = 'ü§ñ Generate AI Summary';
      }
    });

    async function gatherPatientData(patientId) {
      try {
        // Fetch all patient data for AI analysis
        const [encountersRes, medicationsRes, conditionsRes] = await Promise.all([
          fetch(`http://localhost:8080/fhir/Encounter?subject=Patient/${patientId}&_count=50`),
          fetch(`http://localhost:8080/fhir/MedicationRequest?subject=Patient/${patientId}&_count=50`),
          fetch(`http://localhost:8080/fhir/Condition?subject=Patient/${patientId}&_count=50`)
        ]);
        
        const [encounters, medications, conditions] = await Promise.all([
          encountersRes.json(),
          medicationsRes.json(),
          conditionsRes.json()
        ]);
        
        return {
          patient: window.currentPatient,
          encounters: encounters.entry || [],
          medications: medications.entry || [],
          conditions: conditions.entry || []
        };
      } catch (error) {
        console.error('Error gathering patient data:', error);
        return { patient: window.currentPatient, encounters: [], medications: [], conditions: [] };
      }
    }

    // Save patient changes
    document.getElementById('savePatient').addEventListener('click', async () => {
      if (!window.currentPatient) return;
      
      try {
        const updatedPatient = {
          resourceType: 'Patient',
          id: window.currentPatient.id,
          identifier: window.currentPatient.identifier,
          name: window.currentPatient.name || [{ family: 'Unknown' }],
          birthDate: document.getElementById('patientDob').value || undefined,
          gender: document.getElementById('patientGender').value || undefined,
          address: document.getElementById('patientAddress').textContent.trim() !== '-' ? 
            [{ text: document.getElementById('patientAddress').textContent.trim() }] : undefined
        };
        
        // Update patient in FHIR server
        const response = await fetch(`http://localhost:8080/fhir/Patient/${window.currentPatient.id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/fhir+json'
          },
          body: JSON.stringify(updatedPatient)
        });
        
        if (response.ok) {
          alert('‚úÖ Patient updated successfully!');
          window.currentPatient = updatedPatient;
        } else {
          const errorText = await response.text();
          console.error('FHIR server error details:', errorText);
          throw new Error(`Failed to update patient: ${response.status} - ${errorText}`);
        }
      } catch (error) {
        alert(`‚ùå Failed to save changes: ${error.message}`);
        console.error('Save error:', error);
      }
    });

    // Add new encounter
    document.getElementById('addEncounter').addEventListener('click', () => {
      document.getElementById('addEncounterForm').style.display = 'block';
      document.getElementById('addEncounter').style.display = 'none';
      document.getElementById('encounterTypeInput').focus();
    });

    document.getElementById('saveEncounter').addEventListener('click', () => {
      const encounterType = document.getElementById('encounterTypeInput').value.trim();
      if (encounterType && window.currentPatient) {
        addNewEncounter(window.currentPatient.id, encounterType);
        document.getElementById('encounterTypeInput').value = '';
        document.getElementById('addEncounterForm').style.display = 'none';
        document.getElementById('addEncounter').style.display = 'block';
      }
    });

    document.getElementById('cancelEncounter').addEventListener('click', () => {
      document.getElementById('encounterTypeInput').value = '';
      document.getElementById('addEncounterForm').style.display = 'none';
      document.getElementById('addEncounter').style.display = 'block';
    });

    // Add new medication
    document.getElementById('addMedication').addEventListener('click', () => {
      document.getElementById('addMedicationForm').style.display = 'block';
      document.getElementById('addMedication').style.display = 'none';
      document.getElementById('medicationNameInput').focus();
    });

    document.getElementById('saveMedication').addEventListener('click', () => {
      const medicationName = document.getElementById('medicationNameInput').value.trim();
      const medicationDate = document.getElementById('medicationDateInput').value;
      if (medicationName && window.currentPatient) {
        addNewMedication(window.currentPatient.id, medicationName, medicationDate);
        document.getElementById('medicationNameInput').value = '';
        document.getElementById('medicationDateInput').value = '';
        document.getElementById('addMedicationForm').style.display = 'none';
        document.getElementById('addMedication').style.display = 'block';
      }
    });

    document.getElementById('cancelMedication').addEventListener('click', () => {
      document.getElementById('medicationNameInput').value = '';
      document.getElementById('medicationDateInput').value = '';
      document.getElementById('addMedicationForm').style.display = 'none';
      document.getElementById('addMedication').style.display = 'block';
    });

    // Add new condition
    document.getElementById('addCondition').addEventListener('click', () => {
      document.getElementById('addConditionForm').style.display = 'block';
      document.getElementById('addCondition').style.display = 'none';
      document.getElementById('conditionNameInput').focus();
    });

    document.getElementById('saveCondition').addEventListener('click', () => {
      const conditionName = document.getElementById('conditionNameInput').value.trim();
      if (conditionName && window.currentPatient) {
        addNewCondition(window.currentPatient.id, conditionName);
        document.getElementById('conditionNameInput').value = '';
        document.getElementById('addConditionForm').style.display = 'none';
        document.getElementById('addCondition').style.display = 'block';
      }
    });

    document.getElementById('cancelCondition').addEventListener('click', () => {
      document.getElementById('conditionNameInput').value = '';
      document.getElementById('addConditionForm').style.display = 'none';
      document.getElementById('addCondition').style.display = 'block';
    });

    async function addNewEncounter(patientId, encounterType) {
      try {
        const encounter = {
          resourceType: 'Encounter',
          status: 'finished',
          class: { code: 'AMB', display: 'ambulatory' },
          type: [{ text: encounterType }],
          subject: { reference: `Patient/${patientId}` },
          period: { start: new Date().toISOString() }
        };
        
        const response = await fetch('http://localhost:8080/fhir/Encounter', {
          method: 'POST',
          headers: { 'Content-Type': 'application/fhir+json' },
          body: JSON.stringify(encounter)
        });
        
        if (response.ok) {
          // Show success message in a separate area
          const successMsg = document.createElement('div');
          successMsg.textContent = '‚úÖ Encounter added successfully!';
          successMsg.style.cssText = 'background: #d4edda; color: #155724; padding: 8px; border-radius: 4px; margin: 5px 0; font-size: 0.8rem; position: fixed; top: 20px; right: 20px; z-index: 1000;';
          document.body.appendChild(successMsg);
          setTimeout(() => successMsg.remove(), 3000);
          
          // Refresh the encounters list
          await fetchPatientEncounters(patientId);
        } else {
          throw new Error(`Failed to add encounter: ${response.status}`);
        }
      } catch (error) {
        alert(`‚ùå Failed to add encounter: ${error.message}`);
      }
    }

    async function addNewMedication(patientId, medicationName, medicationDate) {
      try {
        const medication = {
          resourceType: 'MedicationRequest',
          status: 'active',
          intent: 'order',
          subject: { reference: `Patient/${patientId}` },
          medicationCodeableConcept: { text: medicationName },
          authoredOn: medicationDate || new Date().toISOString()
        };
        
        const response = await fetch('http://localhost:8080/fhir/MedicationRequest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/fhir+json' },
          body: JSON.stringify(medication)
        });
        
        if (response.ok) {
          // Show success message in a separate area
          const successMsg = document.createElement('div');
          successMsg.textContent = '‚úÖ Medication added successfully!';
          successMsg.style.cssText = 'background: #d4edda; color: #155724; padding: 8px; border-radius: 4px; margin: 5px 0; font-size: 0.8rem; position: fixed; top: 20px; right: 20px; z-index: 1000;';
          document.body.appendChild(successMsg);
          setTimeout(() => successMsg.remove(), 3000);
          
          // Refresh the medications list
          await fetchPatientMedications(patientId);
        } else {
          throw new Error(`Failed to add medication: ${response.status}`);
        }
      } catch (error) {
        alert(`‚ùå Failed to add medication: ${error.message}`);
      }
    }

    async function addNewCondition(patientId, conditionName) {
      try {
        const condition = {
          resourceType: 'Condition',
          subject: { reference: `Patient/${patientId}` },
          code: { text: conditionName },
          clinicalStatus: { coding: [{ code: 'active' }] }
        };
        
        const response = await fetch('http://localhost:8080/fhir/Condition', {
          method: 'POST',
          headers: { 'Content-Type': 'application/fhir+json' },
          body: JSON.stringify(condition)
        });
        
        if (response.ok) {
          // Show success message in a separate area
          const successMsg = document.createElement('div');
          successMsg.textContent = '‚úÖ Condition added successfully!';
          successMsg.style.cssText = 'background: #d4edda; color: #155724; padding: 8px; border-radius: 4px; margin: 5px 0; font-size: 0.8rem; position: fixed; top: 20px; right: 20px; z-index: 1000;';
          document.body.appendChild(successMsg);
          setTimeout(() => successMsg.remove(), 3000);
          
          // Refresh the conditions list
          await fetchPatientConditions(patientId);
        } else {
          throw new Error(`Failed to add condition: ${response.status}`);
        }
      } catch (error) {
        alert(`‚ùå Failed to add condition: ${error.message}`);
      }
    }

    async function fetchPatientEncounters(patientId) {
      try {
        console.log('Fetching encounters for patient:', patientId);
        const response = await fetch(`http://localhost:8080/fhir/Encounter?subject=Patient/${patientId}&_count=10`);
        const bundle = await response.json();
        console.log('Encounters response:', bundle);
        
        const encountersDiv = document.getElementById('recentEncounters');
        if (bundle.total > 0) {
          encountersDiv.innerHTML = bundle.entry.map(entry => {
            const encounter = entry.resource;
            const date = encounter.period?.start ? new Date(encounter.period.start).toLocaleDateString() : 'Unknown date';
            return `
              <div class="encounter-item">
                <div class="encounter-date">${date}</div>
                <div class="encounter-type">${encounter.type?.[0]?.text || encounter.class?.display || 'Clinical encounter'}</div>
              </div>
            `;
          }).join('');
        } else {
          encountersDiv.innerHTML = '<p class="no-data">No recent encounters</p>';
        }
      } catch (error) {
        console.error('Error fetching encounters:', error);
      }
    }

    async function fetchPatientMedications(patientId) {
      try {
        console.log('Fetching medications for patient:', patientId);
        const response = await fetch(`http://localhost:8080/fhir/MedicationRequest?subject=Patient/${patientId}&_count=10`);
        const bundle = await response.json();
        console.log('Medications response:', bundle);
        
        const medicationsDiv = document.getElementById('currentMedications');
        if (bundle.total > 0) {
          medicationsDiv.innerHTML = bundle.entry.map(entry => {
            const medication = entry.resource;
            const date = medication.authoredOn ? new Date(medication.authoredOn).toLocaleDateString() : 'Unknown date';
            return `
              <div class="medication-item">
                <div class="medication-date">${date}</div>
                <div class="medication-name">${medication.medicationCodeableConcept?.text || 'Unknown medication'}</div>
              </div>
            `;
          }).join('');
        } else {
          medicationsDiv.innerHTML = '<p class="no-data">No current medications</p>';
        }
      } catch (error) {
        console.error('Error fetching medications:', error);
      }
    }

    async function fetchPatientConditions(patientId) {
      try {
        console.log('Fetching conditions for patient:', patientId);
        const response = await fetch(`http://localhost:8080/fhir/Condition?subject=Patient/${patientId}&clinical-status=active&_count=10`);
        const bundle = await response.json();
        console.log('Conditions response:', bundle);
        
        const conditionsDiv = document.getElementById('patientConditions');
        if (bundle.total > 0) {
          conditionsDiv.innerHTML = bundle.entry.map(entry => {
            const condition = entry.resource;
            return `
              <div class="condition-item">
                <div class="condition-name">${condition.code?.text || 'Unknown condition'}</div>
              </div>
            `;
          }).join('');
        } else {
          conditionsDiv.innerHTML = '<p class="no-data">No active conditions</p>';
        }
      } catch (error) {
        console.error('Error fetching conditions:', error);
      }
    }

    // Voice Activity Detection using WebRTC
    class VADProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.threshold = 0.01; // Voice detection threshold
        this.silenceFrames = 0;
        this.maxSilenceFrames = 30; // ~0.6 seconds at 48kHz
        this.isVoiceActive = false;
      }

      process(inputs, outputs, parameters) {
        const input = inputs[0];
        const output = outputs[0];
        
        if (input.length > 0) {
          const inputChannel = input[0];
          const outputChannel = output[0];
          
          // Calculate RMS (Root Mean Square) for voice detection
          let sum = 0;
          for (let i = 0; i < inputChannel.length; i++) {
            sum += inputChannel[i] * inputChannel[i];
          }
          const rms = Math.sqrt(sum / inputChannel.length);
          
          // Voice activity detection
          if (rms > this.threshold) {
            this.isVoiceActive = true;
            this.silenceFrames = 0;
          } else {
            this.silenceFrames++;
            if (this.silenceFrames > this.maxSilenceFrames) {
              this.isVoiceActive = false;
            }
          }
          
          // Pass through audio only if voice is detected
          if (this.isVoiceActive) {
            for (let i = 0; i < inputChannel.length; i++) {
              outputChannel[i] = inputChannel[i];
            }
          } else {
            // Silence the output during non-voice periods
            for (let i = 0; i < inputChannel.length; i++) {
              outputChannel[i] = 0;
            }
          }
          
          // Send voice activity status to main thread
          this.port.postMessage({ voiceActive: this.isVoiceActive, rms: rms });
        }
        
        return true;
      }
    }

    // Register the VAD processor
    async function setupVAD(stream) {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create VAD processor worklet
        const vadWorklet = `
          class VADProcessor extends AudioWorkletProcessor {
            constructor() {
              super();
              this.threshold = 0.01;
              this.silenceFrames = 0;
              this.maxSilenceFrames = 30;
              this.isVoiceActive = false;
              this.voiceBuffer = [];
              this.bufferSize = 4800; // 100ms at 48kHz
            }

            process(inputs, outputs, parameters) {
              const input = inputs[0];
              const output = outputs[0];
              
              if (input.length > 0) {
                const inputChannel = input[0];
                const outputChannel = output[0];
                
                let sum = 0;
                for (let i = 0; i < inputChannel.length; i++) {
                  sum += inputChannel[i] * inputChannel[i];
                }
                const rms = Math.sqrt(sum / inputChannel.length);
                
                if (rms > this.threshold) {
                  this.isVoiceActive = true;
                  this.silenceFrames = 0;
                } else {
                  this.silenceFrames++;
                  if (this.silenceFrames > this.maxSilenceFrames) {
                    this.isVoiceActive = false;
                  }
                }
                
                // Only output audio during voice activity
                if (this.isVoiceActive) {
                  for (let i = 0; i < inputChannel.length; i++) {
                    outputChannel[i] = inputChannel[i];
                  }
                } else {
                  // Complete silence - no audio output
                  for (let i = 0; i < inputChannel.length; i++) {
                    outputChannel[i] = 0;
                  }
                }
                
                this.port.postMessage({ voiceActive: this.isVoiceActive, rms: rms });
              }
              
              return true;
            }
          }
          registerProcessor('vad-processor', VADProcessor);
        `;
        
        const blob = new Blob([vadWorklet], { type: 'application/javascript' });
        const workletUrl = URL.createObjectURL(blob);
        
        await audioContext.audioWorklet.addModule(workletUrl);
        
        sourceNode = audioContext.createMediaStreamSource(stream);
        vadProcessor = new AudioWorkletNode(audioContext, 'vad-processor');
        
        // Connect audio pipeline: source -> VAD -> destination
        sourceNode.connect(vadProcessor);
        
        // Create output stream from VAD processor
        const destination = audioContext.createMediaStreamDestination();
        vadProcessor.connect(destination);
        
        // Monitor voice activity
        vadProcessor.port.onmessage = (event) => {
          const { voiceActive, rms } = event.data;
          updateVoiceIndicator(voiceActive, rms);
        };
        
        return destination.stream;
      } catch (error) {
        console.error('VAD setup failed:', error);
        return stream; // Fallback to original stream
      }
    }

    function updateVoiceIndicator(voiceActive, rms) {
      const indicator = document.getElementById('voiceIndicator');
      if (!indicator) {
        // Create voice activity indicator
        const div = document.createElement('div');
        div.id = 'voiceIndicator';
        div.style.cssText = `
          position: fixed; top: 10px; left: 10px; 
          padding: 8px 12px; border-radius: 20px; 
          font-size: 0.8rem; font-weight: bold;
          transition: all 0.2s ease; z-index: 1000;
        `;
        document.body.appendChild(div);
      }
      
      const indicator2 = document.getElementById('voiceIndicator');
      if (voiceActive) {
        indicator2.textContent = `üé§ Voice Detected (${(rms * 100).toFixed(1)}%)`;
        indicator2.style.background = '#d4edda';
        indicator2.style.color = '#155724';
      } else {
        indicator2.textContent = 'üîá Silence';
        indicator2.style.background = '#f8d7da';
        indicator2.style.color = '#721c24';
      }
    }
    navigator.mediaDevices.getUserMedia({ audio: true }).then(() => {
      return navigator.mediaDevices.enumerateDevices();
    }).then(devices => {
      devices.filter(device => device.kind === 'audioinput').forEach(device => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.text = device.label || `Microphone ${micSelect.options.length}`;
        micSelect.appendChild(option);
      });
    });

    btn.onclick = async () => {
      if (!recorder || recorder.state === 'inactive') {
        const patientId = document.getElementById('patientId').value;
        const deviceId = micSelect.value;
        vadEnabled = document.getElementById('vadToggle').checked;
        
        if (!patientId.trim()) {
          status.textContent = 'Please enter Patient ID first';
          return;
        }
        if (!deviceId) {
          status.textContent = 'Please select a microphone first';
          return;
        }
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: { 
            deviceId: { exact: deviceId },
            sampleRate: 48000,
            channelCount: 1,
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          } 
        });

        recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        chunks = [];
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = async () => {
          // Stop all tracks
          stream.getTracks().forEach(t => t.stop());
          
          const blob = new Blob(chunks, { type: 'audio/webm' });

          try {
            // Upload and process as before
            status.textContent = 'Getting upload URL...';
            const urlRes = await fetch(`${API_URL}/get-upload-url?patientId=${encodeURIComponent(patientId)}`);
            const { upload_url, key } = await urlRes.json();

            status.textContent = 'Uploading to S3...';
            await fetch(upload_url, {
              method: 'PUT',
              body: blob,
              headers: { 'Content-Type': 'audio/webm' }
            });

            await fetch(`${API_URL}/upload-complete`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ key: key })
            });

            status.textContent = 'Processing transcription...';
            const resultData = await waitForWebSocketResult(key);
            
            result.style.display = 'block';
            result.innerHTML = '<strong>Result:</strong><pre>' + JSON.stringify(resultData, null, 2) + '</pre>';
            status.textContent = 'Done';

            if (resultData.fhir_bundle) {
              currentFhirBundle = resultData.fhir_bundle;
              sendToFhirBtn.style.display = 'inline-block';
            }
          } catch (err) {
            status.textContent = 'Error: ' + err.message;
          }
        };

        recorder.start();
        btn.textContent = 'Stop Recording';
        btn.classList.add('recording');
        status.textContent = 'Recording (VAD will be applied server-side)...';
        isRecording = true;
      } else {
        recorder.stop();
        btn.textContent = 'Start Recording';
        btn.classList.remove('recording');
        isRecording = false;
      }
    };

    document.getElementById('uploadFile').onclick = async () => {
      const patientId = document.getElementById('patientId').value;
      const fileInput = document.getElementById('audioFile');
      
      if (!patientId.trim()) {
        status.textContent = 'Please enter Patient ID first';
        return;
      }
      if (!fileInput.files[0]) {
        status.textContent = 'Please select an audio file first';
        return;
      }

      try {
        let file = fileInput.files[0];
        
        // Convert to WebM if not already WebM
        if (!file.type.includes('webm')) {
          status.textContent = 'Converting audio format...';
          file = await convertToWebM(file);
        }
        
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        
        status.textContent = 'Getting upload URL...';
        const urlRes = await fetch(`${API_URL}/get-upload-url?patientId=${encodeURIComponent(patientId)}`);
        const { upload_url, key } = await urlRes.json();

        status.textContent = 'Uploading file...';
        progressContainer.style.display = 'block';
        
        // Start timer
        startTime = Date.now();
        timer.style.display = 'block';
        timerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          timerValue.textContent = elapsed;
        }, 1000);
        
        // Use presigned URL (works for large files)
        const uploadPromise = fetch(upload_url, {
          method: 'PUT',
          body: file,
          headers: {
            'Content-Type': 'application/octet-stream'
          }
        });
        
        // Simulate progress for user feedback
        let progress = 0;
        const progressInterval = setInterval(() => {
          progress += Math.random() * 15;
          if (progress > 90) progress = 90;
          progressBar.style.width = progress + '%';
          progressText.textContent = Math.round(progress) + '%';
        }, 200);
        
        await uploadPromise;
        // Key is already available from the initial request
        
        clearInterval(progressInterval);
        progressBar.style.width = '100%';
        progressText.textContent = '100%';
        setTimeout(() => progressContainer.style.display = 'none', 500);
        
        // Trigger processing since S3 events are broken
        await fetch(`${API_URL}/upload-complete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key: key })
        });
        
        status.textContent = 'Processing transcription...';
        
        // Use WebSocket for real-time updates
        const resultData = await waitForWebSocketResult(key);
        
        result.style.display = 'block';
        result.innerHTML = '<strong>Result:</strong><pre>' + JSON.stringify(resultData, null, 2) + '</pre>';
        status.textContent = 'Done';
        
        // Show FHIR button if bundle exists
        if (resultData.fhir_bundle) {
          currentFhirBundle = resultData.fhir_bundle;
          sendToFhirBtn.style.display = 'inline-block';
        }
        
        // Stop timer
        if (timerInterval) {
          clearInterval(timerInterval);
          const totalTime = Math.floor((Date.now() - startTime) / 1000);
          timerValue.textContent = totalTime;
        }
      } catch (err) {
        status.textContent = 'Error: ' + err.message;
        if (timerInterval) clearInterval(timerInterval);
      }
    };

    // Convert audio file to WebM format
    async function convertToWebM(audioFile) {
      return new Promise((resolve, reject) => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const fileReader = new FileReader();
        
        fileReader.onload = async (e) => {
          try {
            const arrayBuffer = e.target.result;
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Create MediaStream from AudioBuffer
            const mediaStreamDestination = audioContext.createMediaStreamDestination();
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(mediaStreamDestination);
            
            // Record to WebM
            const mediaRecorder = new MediaRecorder(mediaStreamDestination.stream, { 
              mimeType: 'audio/webm' 
            });
            const chunks = [];
            
            mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
            mediaRecorder.onstop = () => {
              const webmBlob = new Blob(chunks, { type: 'audio/webm' });
              resolve(webmBlob);
            };
            
            mediaRecorder.start();
            source.start();
            
            // Stop recording when audio ends
            setTimeout(() => {
              mediaRecorder.stop();
              source.stop();
            }, audioBuffer.duration * 1000);
            
          } catch (error) {
            reject(error);
          }
        };
        
        fileReader.onerror = reject;
        fileReader.readAsArrayBuffer(audioFile);
      });
    }

    async function waitForWebSocketResult(key) {
      return new Promise((resolve, reject) => {
        const ws = new WebSocket(WEBSOCKET_URL);
        
        ws.onopen = () => {
          // Subscribe to updates for this audio key
          ws.send(JSON.stringify({
            action: 'subscribe',
            audioKey: key
          }));
        };
        
        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.type === 'completed' && data.audioKey === key) {
            ws.close();
            resolve(data.result);
          }
        };
        
        ws.onerror = () => {
          ws.close();
          // Fallback to polling if WebSocket fails
          pollForResult(key).then(resolve).catch(reject);
        };
        
        // Timeout after 10 minutes
        setTimeout(() => {
          ws.close();
          reject(new Error('Processing timeout'));
        }, 600000);
      });
    }

    async function pollForResult(key, maxAttempts = 60, interval = 5000) {
      for (let i = 0; i < maxAttempts; i++) {
        await new Promise(r => setTimeout(r, interval));
        const res = await fetch(`${API_URL}/result/${encodeURIComponent(key)}`);
        if (res.ok) {
          return await res.json();
        }
        // Update status to show progress
        status.textContent = `Processing transcription... (${i + 1}/${maxAttempts})`;
      }
      throw new Error('Processing timeout');
    }

    // Send FHIR bundle to server
    sendToFhirBtn.onclick = async () => {
      if (!currentFhirBundle) {
        alert('No FHIR bundle available');
        return;
      }
      
      try {
        sendToFhirBtn.textContent = 'Sending...';
        sendToFhirBtn.disabled = true;
        
        const response = await fetch('http://localhost:8080/fhir', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/fhir+json'
          },
          body: JSON.stringify(currentFhirBundle)
        });
        
        if (response.ok) {
          const result = await response.json();
          alert('‚úÖ FHIR bundle sent successfully!');
          console.log('FHIR response:', result);
        } else {
          const errorText = await response.text();
          console.error('FHIR server error details:', errorText);
          throw new Error(`FHIR server error: ${response.status} - ${errorText}`);
        }
      } catch (error) {
        alert(`‚ùå Failed to send to FHIR server: ${error.message}`);
        console.error('FHIR error:', error);
      } finally {
        sendToFhirBtn.textContent = 'Send to FHIR Server';
        sendToFhirBtn.disabled = false;
      }
    };
  </script>
</body>
</html>
